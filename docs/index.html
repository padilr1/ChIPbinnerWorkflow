<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Reinnier Padilla" />


<title>Analyzing binned ChIP-seq/Cut&amp;Run data with ChIPbinner</title>

<script src="site_libs/header-attrs-2.26/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">ChIPbinner</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Workflow</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Analyzing binned ChIP-seq/Cut&amp;Run data
with ChIPbinner</h1>
<h4 class="author">Reinnier Padilla</h4>

</div>


<pre class="r"><code>library(ChIPbinner)</code></pre>
<div id="database-for-chipbinner" class="section level1">
<h1>Database for ChIPbinner</h1>
<p>Only toy datasets, which have been largely downsampled, are included
with the package. For complete example datasets please see
<a href="https://github.com/padilr1/ChIPbinner_database.git">ChIPbinner
database</a>.</p>
</div>
<div id="example-workflow-for-generating-binned-bed-files"
class="section level1">
<h1>Example workflow for generating binned BED files</h1>
<p>For input into ChIPbinner, the sequenced samples will need to be
binned into windows, and formatted as a
<a href="https://genome.ucsc.edu/FAQ/FAQformat">BED</a> file. One of the
tools that can be used to perform this task is
<a href="https://bedtools.readthedocs.io/en/latest/">BEDtools</a>, which
can convert an aligned sequence file, typically found in a
<a href="https://genome.ucsc.edu/goldenPath/help/bam.html">BAM</a>
format, into a binned BED file as demonstrated below.</p>
<p>Reference windows ($WINDOW_REF) can be found in the
<a href="https://github.com/padilr1/ChIPbinner_database.git">ChIPbinner
database</a>.</p>
<pre class="bash"><code># convert aligned BAM file to BED file
bedtools bamtobed -i ${sample}.sorted.bam | sort -k1,1 -k2,2n &gt; ${sample}.bed
# intersect sample BED file with binned reference files
bedtools intersect -a $WINDOW_REF -b ${sample}.bed -sorted -c -nonamecheck &gt; $OUTPUT_NAME.binned.bed
# example for binning Cal27 WT sample into 10kb windows
bedtools bamtobed -i Cal27.WT.H3K36me2.sorted.bam | sort -k1,1 -k2,2n &gt; Cal27.WT.H3K36me2.bed
bedtools intersect -a hg38.10kb.windows.bed -b Cal27.WT.H3K36me2.bed -sorted -c -nonamecheck &gt; Cal27.WT.H3K36me2.10kb.bed</code></pre>
</div>
<div id="filtering-bins-depleted-in-signal-across-samples"
class="section level1">
<h1>Filtering bins depleted in signal across samples</h1>
<p>Using the <code>filter_low_counts</code> function, the user can
remove bins with consistently low raw read counts (e.g., for a given
bin, if all four samples have a raw read count less than 100, it is
filtered out). This filtering step reduces computational time and
enhances the power to detect differential binding.</p>
<pre class="r"><code>filter_low_counts(out_dir, hg38, sample_bedfiles = c(&quot;NSD1KO_rep1.bed&quot;,
    &quot;NSD1KO_rep2.bed&quot;, &quot;WT_rep1.bed&quot;, &quot;WT_rep2.bed&quot;), cutoff = 100)</code></pre>
</div>
<div id="normalizing-raw-counts-by-size-factors" class="section level1">
<h1>Normalizing raw counts by size factors</h1>
<p>The user can choose to normalize the raw counts in their BED files
using
<a href="https://bioconductor.org/packages/release/bioc/html/DESeq2.html">DESeq2’s
median ratio method</a> or
<a href="https://bioconductor.org/packages/release/bioc/html/edgeR.html">edgeR’s
TMM</a>. In this case, DESeq2’s median ratio method will divide the raw
bin counts by sample-specific size factors, which are calculated by
determining the median of the ratio of the raw bin counts for each bin
relative to the geometric mean per bin across all samples. Conversely,
edgeR’s TMM method will compute the TMM factor by considering one sample
as a reference sample and the other as test samples. The sample with the
count-per-million upper quartile closest to the mean upper quartile is
designated as the reference. For each test sample, TMM is calculated as
the weighted mean of log ratios between the test sample and the
reference, excluding bins with the highest coverage and those with the
largest log ratios. EdgeR assumes that there are few differential
changes, so the TMM should be close to 1. If it’s not, the TMM value
indicates the correction factor that should be applied to the library
sizes, resulting in what is referred to as the effective library size.
The normalized read counts are then calculated by dividing the raw bin
counts by the effective library size.</p>
<p>In addition to correcting for technical biases arising from
differences in sequencing depth across samples, both methods utilize
normalization factors to address outlier regions that could distort
comparisons of read counts per bin across samples. Thus, both methods
are robust to outliers and bins with extremely high or low coverage.
However, it is important to note that both methods assume most bins are
not differentially covered (or differentially bound) between samples.
<b> While these normalization methods enhance robustness against outlier
regions, it also reduces sensitivity to detecting positive instances of
differential changes. Therefore, users should exercise caution when
applying these normalization techniques as they may reduce the power to
detect true biological changes for a given histone mark. </b></p>
<p>Multiple samples per condition (treated and wildtype) can be provided
for this normalization. The function will then output the normalized
counts in separate BED files for each sample. The user can then input
these files into the next step — generating normalized bigWig files —
where additional normalization and/or scaling of the signal can be
performed.</p>
<pre class="r"><code># using DESeq2&#39;s median ratio method
apply_normFactors(norm_method = &quot;DESeq2&quot;, out_dir = &quot;out_dir&quot;,
    genome_assembly = &quot;mm10&quot;, treated_sample_bedfiles = c(&quot;Cal27_NSD1KO_H3K36me2_rep1.10kb.bed&quot;,
        &quot;Cal27_NSD1KO_H3K36me2_rep2.10kb.bed&quot;), wildtype_sample_bedfiles = c(&quot;Cal27_WT_H3K36me2_rep1.10kb.bed&quot;,
        &quot;Cal27_WT_H3K36me2_rep2.10kb.bed&quot;), treated_condition_label = &quot;NSD1KO&quot;,
    wildtype_condition_label = &quot;WT&quot;)
# using edgeR&#39;s TMM
apply_normFactors(norm_method = &quot;edgeR&quot;, out_dir = &quot;out_dir&quot;,
    genome_assembly = &quot;mm10&quot;, treated_sample_bedfiles = c(&quot;Cal27_NSD1KO_H3K36me2_rep1.10kb.bed&quot;,
        &quot;Cal27_NSD1KO_H3K36me2_rep2.10kb.bed&quot;), wildtype_sample_bedfiles = c(&quot;Cal27_WT_H3K36me2_rep1.10kb.bed&quot;,
        &quot;Cal27_WT_H3K36me2_rep2.10kb.bed&quot;), treated_condition_label = &quot;NSD1KO&quot;,
    wildtype_condition_label = &quot;WT&quot;)</code></pre>
</div>
<div id="generating-normalized-bigwig-files" class="section level1">
<h1>Generating normalized bigwig files</h1>
<p>When you bin your files into windows, especially from aligned (BAM or
SAM) files, they are typically raw read counts. They will need to be
normalized by the input (highly recommended for ChIP-seq data) and
likely scaled by some factor (we recommend using a normalization scaling
factor like genome-wide modification percentage information obtained
from mass spectrometry, Drosophila spike-in or any other types of
spike-in). This step will have to be performed prior to moving on to the
rest of the workflow.</p>
<p>Here, we are generating normalized bigwig files for 10kb-binned files
(in BED format) for a head and neck squamous cell carcinoma (HNSCC) line
(Cal27) for the broad histone mark H3K36me2 generated via ChIP-seq. The
lysine 36 methyl transferase NSD1 was knocked out in the sample
(NSD1-KO) and is being compared to the wildtype (WT) cell line. Please
see
<a href="https://www.sciencedirect.com/science/article/pii/S2211124721000826?via%3Dihub">Farhangdoost
et al. 2021</a> for more details.</p>
<p><b>Important note 1:</b> For ChIPbinner, only two genome assemblies
can be used: <code>hg38</code> or <code>mm10</code>. We will be using
the <code>hg38</code> assembly for this analysis.</p>
<p><b>Important note 2:</b> If you’ve previously ran
<code>apply_normFactors</code> on the BED files, then please use the
parameter <code>depth_norm = FALSE </code> to avoid redundantly
normalizing the read counts by library size.</p>
<p>If you’ve ran the code chunk successfully, your resulting bigwig
files will be found in the <code>output_directory</code> that you
specified when running the function. The
<code>immunoprecipitated_binned_file</code> refers to the
immunoprecipitated sample for ChIP-seq or the targeted, enriched sample
for CUT&amp;RUN/TAG. The <code>input_binned_file</code> refers to the
genomic input for ChIP-seq samples or the IgG control sample for
CUT&amp;RUN/TAG.</p>
<pre class="r"><code># generate normalized bigwig for WT sample
norm_bw(out_dir = &quot;output_directory&quot;, genome_assembly = &quot;hg38&quot;,
    immunoprecipitated_binned_file = &quot;Cal27.WT.H3K36me2.10kb.bed&quot;,
    use_input = TRUE, depth_norm = TRUE, input_binned_file = &quot;Cal27.WT_input.H3K36me2.10kb.bed&quot;,
    raw_count_cutoff = 0, pseudocount = 1e-15, scaling_factor = 0.450328805)
# generate normalized bigwig for NSD1-KO sample
norm_bw(out_dir = &quot;output_directory&quot;, genome_assembly = &quot;hg38&quot;,
    immunoprecipitated_binned_file = &quot;Cal27.NSD1_KO.H3K36me2.10kb.bed&quot;,
    use_input = TRUE, depth_norm = TRUE, input_binned_file = &quot;Cal27.NSD1_KO_input.H3K36me2.10kb.bed&quot;,
    raw_count_cutoff = 0, pseudocount = 1e-15, scaling_factor = 0.192272095)</code></pre>
</div>
<div
id="generating-scatterplots-with-bins-stratified-into-genic-and-intergenic-regions"
class="section level1">
<h1>Generating scatterplots with bins stratified into genic and
intergenic regions</h1>
<p>After normalizing and converting the binned BED files into bigwigs,
we can read them in and generate a scatterplot comparing two cell lines.
The scatterplot will annotate genic and intergenic regions accordingly.
The resulting figures will be found in <code>/output_directory</code>
for the code chunk below.</p>
<p>Genic and intergenic regions for <code>hg38</code> and
<code>mm10</code> are included with the package and can be accessed as
indicated in the code chunk below. <b> Note: you will need to adjust the
minimum and maximum values for the x- and y-axis accordingly. To find
optimal values for the x- and y-axis, run <code>pre_clust</code> to
create an exploratory scatterplot of the samples you’re
comparing.</b></p>
<pre class="r"><code>genic_intergenic_scatterplot(out_dir = &quot;output_directory&quot;, genome_assembly = &quot;hg38&quot;,
    cell_line = &quot;Cal27&quot;, wildtype_samp_norm_bw = &quot;Cal27.WT.H3K36me2.10kb.norm.bw&quot;,
    treated_samp_norm_bw = &quot;Cal27.NSD1_KO.H3K36me2.10kb.norm.bw&quot;,
    are_R_objects = FALSE, histone_mark = &quot;H3K36me2&quot;, output_filename = &quot;Cal27.WT_NSD1KO.H3K36me2.10kb&quot;,
    title_of_plot = &quot;Cal27 ChIP-seq H3K36me2&quot;, xaxis_label = &quot;WT&quot;,
    yaxis_label = &quot;NSD1_KO&quot;, max_x = 1, max_y = 1, min_x = -5,
    min_y = -5, pow = 1.25, show_scales = FALSE, show_legend = TRUE,
    legend_pos = &quot;left&quot;)</code></pre>
</div>
<div id="exploratory-analyses" class="section level1">
<h1>Exploratory analyses</h1>
<div id="pca" class="section level2">
<h2>PCA</h2>
<p>Plots of principal component analysis can be generated using
<code>plot_PCA</code> with an example below. PCA plots are useful for
assessing the treatment effect and the consistency of replicates.</p>
<pre class="r"><code>plot_PCA(
  out_dir = &quot;outdir&quot;,
  output_filename = &quot;PCA_plot&quot;,
  colors = c(&quot;blue&quot;, &quot;blue3&quot;, &quot;red&quot;, &quot;red4&quot;, &quot;forestgreen&quot;, &quot;green1&quot;),
  sample_labels = c(&quot;samp_1&quot;, &quot;samp_2&quot;, &quot;samp_3&quot;, &quot;samp_4&quot;, &quot;samp_5&quot;, &quot;samp_6&quot;),
  plot_title = &quot;&quot;,
  plot_height = 8,
  plot_width = 12,
  &quot;samp1_10kb.norm.bw&quot;,
  &quot;samp2_10kbb.norm.bw&quot;,
  &quot;samp3_10kbb.norm.bw&quot;,
  &quot;samp4_10kbb.norm.bw&quot;,
  &quot;samp5_10kbb.norm.bw&quot;,
  &quot;samp6_10kbb.norm.bw&quot;,
)</code></pre>
</div>
<div id="correlation-plots" class="section level2">
<h2>Correlation plots</h2>
<p>Correlation plots can be generated using
<code>plot_correlation</code> with an example below. Correlation plots
are useful for assessing separation of samples according to treatment
and consistency of replicates.</p>
<pre class="r"><code>plot_correlation(
  out_dir = &quot;outdir&quot;,
  output_filename = &quot;correlation_plot&quot;,
  sample_labels = c(&quot;samp_1&quot;, &quot;samp_2&quot;, &quot;samp_3&quot;, &quot;samp_4&quot;, &quot;samp_5&quot;, &quot;samp_6&quot;),
  colors = c(&quot;blue&quot;, &quot;blue3&quot;, &quot;red&quot;, &quot;red4&quot;, &quot;forestgreen&quot;, &quot;green1&quot;),
  plot_height = 4,
  plot_width = 4,
  &quot;samp1_10kb.norm.bw&quot;,
  &quot;samp2_10kbb.norm.bw&quot;,
  &quot;samp3_10kbb.norm.bw&quot;,
  &quot;samp4_10kbb.norm.bw&quot;,
  &quot;samp5_10kbb.norm.bw&quot;,
  &quot;samp6_10kbb.norm.bw&quot;
)</code></pre>
</div>
</div>
<div id="combining-replicates" class="section level1">
<h1>Combining replicates</h1>
<p>Replicates for a given treatment can be combined using
<code>merge_norm_bw</code>. The merged bigWig file can be used for
downstream analysis.</p>
<pre class="r"><code>merge_norm_bw(
  rep1 = &quot;WT_rep1_10kb_norm.bw&quot;,
  rep2 = &quot;WT_rep2_10kb_norm.bw&quot;,
  merged_samples_label = &quot;merged_WT&quot;,
  out_dir = &quot;outdir&quot;
)</code></pre>
</div>
<div id="identifying-clusters-of-similarly-behaving-genomic-bins"
class="section level1">
<h1>Identifying clusters of similarly-behaving genomic bins</h1>
<div id="processing-bigwig-files-for-clustering" class="section level2">
<h2>Processing bigwig files for clustering</h2>
<p>Prior to generating clusters, we need to pre-process the normalized
bigWig files, which entails finding overlapping regions between two
bigWig files, removing the bottom and top 1% of bins across the two
samples (trimming to make the graphics more visible) and finally
generating a matrix of scores as well as a BED file of coordinates to be
used with HDBScan for generating clusters of similarly-behaving bins.
This is accomplished using the <code>pre_clus()</code> function. We will
continue to use the samples from the previous steps above.</p>
<p><b>Important note: Normally, bigWig files are used as input
throughout the workflow. However, R objects of the bigWig files can also
be used, but must specified by setting
<code>are_R_objects=TRUE</code></b>.</p>
<pre class="r"><code>pre_clust(
  out_dir = &quot;output_directory&quot;,
  treated_samp_norm_bw = &quot;Cal27.WT.H3K36me2.10kb.norm.bw&quot;,
  wildtype_samp_norm_bw = &quot;Cal27.NSD1_KO.H3K36me2.10kb.norm.bw&quot;,
  output_filename = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb&quot;,
  are_R_objects = FALSE
)</code></pre>
</div>
<div id="matrix-and-pooled-bed-file-of-genomic-coordinates"
class="section level2">
<h2>Matrix and pooled BED file of genomic coordinates</h2>
<p>The resulting <code>mat.csv</code> and <code>pooled.bed</code> from
the <code>pre_clust()</code> function can be used to retrieve a matrix
of normalized signals for the two samples being compared at a given
genomic window, as shown below.</p>
<pre class="r"><code>genomic_coordinates &lt;- data.table::fread(&quot;pooled.bed&quot;)
signals &lt;- data.table::fread(&quot;mat.csv&quot;) %&gt;% `names&lt;-`(c(&quot;KO&quot;, &quot;WT&quot;))
normalized_signal_matrix &lt;- cbind(genomic_coordinates, signals)</code></pre>
</div>
<div id="running-hdbscan-to-generate-clusters" class="section level2">
<h2>Running HDBSCAN to generate clusters</h2>
<p>The <code>clus()</code> function can be used to generate clusters of
similarly-behaving genomic bins. It is based on an unsupervised learning
algorithm to find clusters, or dense regions, of a dataset. More details
on the Hierarchical Density-Based Spatial Clustering of Applications
with Noise (HDBSCAN) algorithm can be found
<a href="https://hdbscan.readthedocs.io/en/latest/index.html">here</a>.
The function uses <code>reticulate</code> as an interface to a Python
session. <b>Python version 3.9 will need to be installed in your
environment prior to running the function.</b> No other actions are
required from the user, as the minimal Python packages are automatically
installed in an isolated virtual environment specifically designated for
the ChIPbinner R package. This minimizes the risk of inadvertently
disrupting another Python installation on the user’s system.</p>
<p><b>It is important to consider this step will require substantial
processing memory as well as time </b>. Thus, it is recommended that you
use the python-implementation of HDBSCAN in a High-performance Computing
server instead. Nevertheless, an example workflow for running HDBSCAN is
found below. Here, we use the complete matrix file, which required
substantial processing memory and multiple parallel cores, typically
found in a high-performance computing cluster. The complete matrix file
can be found at the
<a href="https://github.com/padilr1/ChIPbinner_database.git">ChIPbinner
database</a>.</p>
<pre class="r"><code># using the complete matrix
generate_clust(
  output_file_name = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb&quot;,
  out_dir = &quot;output_directory&quot;,
  matrix_file = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb.mat.csv&quot;,
  minpts = 5000,
  minsamps = 5000,
  cores = 6
)</code></pre>
</div>
<div id="annotating-clusters" class="section level2">
<h2>Annotating clusters</h2>
<p>After identifying clusters using HDBSCAN, these clusters need to be
annotated for use in downstream analysis. The resulting R object
contains genomic coordinates for each cluster, which can be accessed by
referencing the elements within the object list, as demonstrated below.
Each cluster will be in a
<a href="https://bioconductor.org/packages/devel/bioc/vignettes/GenomicRanges/inst/doc/GenomicRangesIntroduction.html">GRanges</a>
format.</p>
<pre class="r"><code>annotate_clust(
  number_of_clusters = 3,
  matrix_file = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb_mat.csv&quot;,
  pooled_bed_file = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb_pooled.bed&quot;,
  hdbscan_output_file = &quot;clus.Cal27.WT.NSD1_KO.H3K36me2.10kb.5000.5000.txt&quot;,
  output_filename = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb&quot;,
  out_dir = &quot;output_directory&quot;
)
# access each cluster, which will be in the GRanges format
cluster_A &lt;- cons$A
cluster_B &lt;- cons$B
cluster_C &lt;- cons$C</code></pre>
</div>
<div id="generating-density-based-scatterplots" class="section level2">
<h2>Generating density-based scatterplots</h2>
<p>Finally, a density-based cluster scatterplot (along with the
genic/intergenic scatterplot) can be generated using
<code>density_based_scatterplot()</code>. Here, we used the complete
matrix of enrichment scores to generate the HBDSCAN output. The complete
HDBSCAN output can found at
<a href="https://github.com/padilr1/ChIPbinner_database.git">ChIPbinner
database</a>.The user can choose to include an additional density plot
that displays only the number of bins in non-annotated regions with the
parameter <code> include_additional_density_plot = TRUE </code>.
Otherwise, this defaults to <code>FALSE</code>.</p>
<pre class="r"><code>density_based_scatterplot(
  out_dir = &quot;output_directory&quot;,
  genome_assembly = &quot;hg38&quot;,
  are_R_objects = FALSE,
  output_filename = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb&quot;,
  wildtype_samp_norm_bw = &quot;Cal27_WT_H3K36me2_10kb.norm.bw&quot;,
  treated_samp_norm_bw = &quot;Cal27_NSD1_KO_H3K36me2_10kb.norm.bw&quot;,
  cell_line = &quot;Cal27&quot;,
  histone_mark = &quot;H3K36me2&quot;,
  annotated_clusters = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb_annotated_clusters.rda&quot;,
  number_of_clusters = 3,
  title_of_plot = &quot;H3K36me2&quot;,
  pow = 1.1,
  min_x = -5,
  min_y = -5,
  max_x = 2,
  max_y = 2,
  hexbins = 50,
  show_scales = FALSE,
  xaxis_label = &quot;WT&quot;,
  yaxis_label = &quot;NSD1_KO&quot;,
  height_of_figure = 6,
  width_of_figure = 15,
  include_additional_density_plot = TRUE,
  filter_extreme_bins = TRUE
)</code></pre>
</div>
</div>
<div id="differential-binding-analysis" class="section level1">
<h1>Differential binding analysis</h1>
<p>If replicates are included per group, differential binding (DB) can
be performed by the user. ChIPbinner uses the
<a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005562">ROTS</a>
method to assess DB between two groups for each bin. Unlike methods
relying on a fixed predefined statistical model, ROTS optimizes the test
statistic directly from the data. This adaptive approach, based on
t-type statistics, ranks genomic features based on the strength of
evidence for differential binding in two-group comparisons. A priori
assumptions about the data distribution or specific cutoffs for ranking
do not need to be specified for ROTS. The optimization process maximizes
the overlap of top-ranked features in bootstrap datasets that maintain
the original group structure.</p>
<p>Previous performance comparisons demonstrated that ROTS, while
exhibiting less power in datasets with a small proportion of
differentially expressed features, surpasses other differential
expression methods, such as edgeR and DESeq2, in datasets characterized
by a large proportion of differentially expressed features and a skewed
distribution of these features – conditions frequently observed in
ChIP-seq data following mutations affecting global histone levels.</p>
<p><b> Running <code>differentialBinAnalysis</code> requires significant
computational resources, including dedicated compute clusters with ample
memory </b>. The <code>bootstrap_value</code> parameter specifies the
number of permutation resamplings to estimate the null distribution of
the test statistic (default 1000). Increasing this value can improve the
precision of your results, but at the expense of greater computational
run-time.The <code>K_value</code> parameter specifies the largest top
list size considered. It is recommended that the K value should be
considerably higher than the number of features expected to be
differentially affected. However, increasing this value will also
substantially increase the computational run-time.</p>
<pre class="r"><code>differentialBinAnalysis(out_dir, genome_assembly = &quot;hg38&quot;, treated_sample_bigWigFiles = c(&quot;Cal27_NSD1KO_H3K36me2_rep1.10kb_norm.bw&quot;,
    &quot;Cal27_NSD1KO_H3K36me2_rep2.10kb_norm.bw&quot;), wildtype_sample_bigWigFiles = c(&quot;Cal27_WT_H3K36me2_rep1.10kb_norm.bw&quot;,
    &quot;Cal27_WT_H3K36me2_rep2.10kb_norm.bw&quot;), treated_condition_label = &quot;NSD1KO&quot;,
    wildtype_condition_label = &quot;WT&quot;, bootstrap_value = 1000,
    K_value = 1e+05, annotated_clusters = &quot;annotated_clusters.rda&quot;)</code></pre>
</div>
<div
id="overlap-enrichmentdepletion-analysis-with-annotated-clusters-of-bins"
class="section level1">
<h1>Overlap enrichment/depletion analysis with annotated clusters of
bins</h1>
<p>After identifying and annotating clusters of bins, a Fisher’s exact
test can be used to determine whether these bins overlap a specific
class of annotated regions against a background of all bins. The
underlying algorithm is based on
<a href="https://bioconductor.org/packages/release/bioc/html/LOLA.html">LOLA
- locus overlap analysis for enrichment of genomic ranges</a>. The
example below evaluates overlap with
<a href="https://useast.ensembl.org/info/genome/index.html">Ensembl</a>
annotations genome-wide. However, the user can also evaluate overlap
with other functional annotations by inputting an R object of the
database of their choice in the parameter
<code>functional_db</code>.</p>
<p>The
<a href="https://github.com/padilr1/ChIPbinner_database.git">ChIPbinner
database</a> contains curated databases ready for input into the
parameter <code>functional_db</code> within the
<code>enrich_clust()</code> function.</p>
<p>Nevertheless, by specifying the <code>region</code> to be either
<code>genic</code> or <code>intergenic</code>, the user can evaluate
exclusively genic or intergenic bins overlapping a specific class of
annotated regions. In these cases, the background is stratified to only
genic or intergenic regions to avoid spurious associations to
annotations confounded by their predominantly genic or intergenic
localization.</p>
<p>Below is an example of how to calculate overlap enrichment &amp;
depletion result of Ensembl annotations with bins found in cluster B
identified from the previous analyses. Note that the size of the dots
corresponds to the number of bins overlapping the corresponding
annotation. The p-value is based on Fisher’s exact test of bins
overlapping a specific class of annotated regions versus a background of
all bins found in both cell lines being compared.</p>
<pre class="r"><code>enrich_clust(
  genome_assembly = &quot;hg38&quot;,
  annotated_clusters = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb_annotated_clusters.rda&quot;,
  query_cluster = &quot;B&quot;,
  pooled_bed_file = &quot;Cal27.WT.NSD1_KO.H3K36me2.10kb_pooled.bed&quot;,
  functional_db = &quot;hg38_ensemblDB.rda&quot;,
  region = &quot;genome_wide&quot;,
  cores = 1,
  n_elements = 7,
  cutoff_for_overlap = 1000,
  file_plot_name = &quot;ensembl.genome_wide.enrichment_depletion&quot;,
  output_table_name = &quot;ensembl.genome_wide.enrichment_depletion&quot;,
  width_of_plot = 7,
  height_of_plot = 3,
  out_dir = &quot;output_directory&quot;
)</code></pre>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
